from time import sleep
import tkinter
from urllib.parse import quote_plus as urlquote, urljoin

from fxi.apps import AppBase
from fxi.slideshow import Slide, ImageSlideShow

import requests
from bs4 import BeautifulSoup


class MySlide(Slide):
    def refresh(self, *args, **kwargs):
        super().refresh(*args, **kwargs)
        if self.text:
            for word in self.text.split(' '):
                if word.startswith('@'):
                    term = word[1:]
                    self.clipboard_clear()
                    self.clipboard_append(term)
                    self.app.info(f'Copied {term} to clipboard.')
                    break


class MySlideShow(ImageSlideShow):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.username = None
        self.full = False

    def next(self, *args, **kwargs):
        super().next(*args, **kwargs)

        num_slides = len(self.slides)
        self.app.info(f'Slide {self.index} of {num_slides}')

        if not self.full and num_slides > 5 and self.index > (num_slides - 4):
            self.app.enqueue(self.app.load_next_page)

    def create_slide(self, item):
        img = item.find('img')
        if not img:
            return

        h3_username = item.find('h3', class_='user-username')
        username = h3_username.find('div').text

        if self.username is None:
            self.username = username
        elif self.username != username:
            self.full = True
            self.app.info('Last slide reached!')
            return

        img_anchor = img.parent
        img_anchor_href = img_anchor.attrs['href']
        img_id = img_anchor_href.split('/')[-1]
        self.app.last_image = img_id

        img_src = img.attrs['src']

        date = item.find('span', class_='created_time') |> .text
        ptext = item.find('p', class_='pintaram-text').text

        slide = MySlide(self.app, relief=tkinter.SUNKEN)
        slide.text = ptext
        slide.date = date
        slide.subtitle = username
        slide.set_image_from_url(img_src)
        self.slides.append(slide)
        slide.render(self.title)


class App(AppBase):
    title = 'Insta'

    def init(self):
        self.entries = {}
        self.base_url = 'https://www.pintaram.com'
        self.slideshow = None
        self.loading_next_page = False

        self.favorites = self.get_config('favorites', {})

    def cmd__s(self, *words):
        """
        Search

        Usage: s <term>
        """
        term = words |> ' '.join |> urlquote

        with self.info(f'Searching for "{term}"...'):
            soup = self.get_soup(f'{self.base_url}/search?query={term}')

        monitor = self.open_monitor(f'Search: {term}')
        index = 0
        self.entries = {}

        def show_entry(anchor):
            nonlocal monitor
            nonlocal index

            href = anchor.attrs.get('href', None)
            if href is None:
                return

            url = urljoin(self.base_url, href)

            img = anchor.find('img')
            thumbnail_url = img.attrs['src']

            result_name_div = anchor.find('div', class_='search-result-name')
            div1, div2, *rest = result_name_div.find_all('div')

            name = div1.text
            nick = div2.text

            monitor.h2(f'{index:>3}: {name}')
            slot = monitor.add_slot()
            self.enqueue(slot.write_image_from_url, thumbnail_url)
            monitor.write(nick)
            monitor.hr()
            self.entries[index] = (name, url)
            index += 1

        content_rows = soup.find_all('div', class_='content-row')
        for row in content_rows[0:50]:
            row.find_all('a') |> map$(show_entry) |> tuple

    def cmd__list(self, index):
        """
        Displays the entry as a list, one post on top
        of another.

        Usage: list <index>
        """
        if index == 'n':
            index = self.current_index + 1
        elif index == 'p':
            index = self.current_index - 1
        else:
            index = int(index)

        name, url = self.entries[index]

        with self.info(f'Downloading {name}...'):
            soup = self.get_soup(url)

        monitor = self.open_monitor(name)
        self.current_url = url
        self.current_name = name
        self.current_index = index
        self.last_image = None

        soup.find_all('div', class_='grid-item') |> map$(self.show_photo) |> tuple

    def cmd__ss(self, index):
        """Slideshow. Same as 'v'"""
        return self.cmd__v(index)

    def cmd__v(self, index):
        """
        View posts as a slideshow.

        Usage: v <index>
        """
        if index == 'n':
            index = self.current_index + 1
        elif index == 'p':
            index = self.current_index - 1
        else:
            index = int(index)

        name, url = self.entries[index]

        self.current_url = url
        self.current_name = name
        self.current_index = index
        self.last_image = None

        self.slideshow?.close()

        if url in self.favorites:
            _, description = self.favorites[url]
            title = f'{name} [FAV: {description}]'
        else:
            title = name

        self.slideshow = MySlideShow(self, title, [])

        with self.info(f'Downloading {name}...'):
            soup = self.get_soup(url)

        with self.info('Creating slides...'):
            soup.find_all('div', class_='grid-item') |> map$(self.slideshow.create_slide) |> tuple

        self.enqueue(self.do_render_slideshow)
        self.slideshow.render()

    def do_render_slideshow(self):
        if len(self.slideshow.slides) == 0 or self.slideshow.slides[0].image_reference is None:
            sleep(0.5)
            self.enqueue(self.do_render_slideshow)
            return

        self.slideshow.refresh()
        self.enqueue(self.load_next_page)

    def cmd__lnp(self):
        """
        Load next page, no matter which you're looking right now

        Usage: lnp
        """
        self.load_next_page()

    def load_next_page(self):
        if self.loading_next_page:
            return

        self.loading_next_page = True
        with self.info('Loading next page...'):
            response = requests.post(self.current_url, data={'nextMaxId': self.last_image})
            response.raise_for_status()

        soup = response.content |> BeautifulSoup
        with self.info('Creating slides...'):
            soup.find_all('div', class_='grid-item') |> map$(self.slideshow.create_slide) |> tuple
        self.loading_next_page = False

    def show_photo(self, item):
        img = item.find('img')
        if not img:
            return

        monitor = self.current_monitor

        img_anchor = img.parent
        img_anchor_href = img_anchor.attrs['href']
        img_id = img_anchor_href.split('/')[-1]
        self.last_image = img_id

        slot = monitor.add_slot()
        self.enqueue(slot.write_image_from_url, img.attrs['src'])

        item.find('span', class_='created_time') |> .text |> monitor.write

        ptext = item.find('p', class_='pintaram-text')
        ptext?.text |> monitor.write

        monitor.hr()

    def get_soup(self, url, **kwargs):
        response = requests.get(url, headers={'Referer': self.base_url}, **kwargs)
        response.raise_for_status()
        return response.content |> BeautifulSoup

    def cmd__f(self, *comment_parts):
        """
        Save a feed/account as favorite.

        Usage: f <tag1>[ <tag2>[ <tag3>[...]]]
        """
        comment = comment_parts |> ' '.join

        name, url = self.entries[self.current_index]
        self.favorites[url] = (name, comment)
        self.set_config('favorites', self.favorites)

        if self.slideshow:
            _, description = self.favorites[url]
            new_title = f'{self.slideshow.title} [FAV: {description}]'
            self.slideshow.title = new_title
            for slide in self.slideshow.slides:
                slide.set_title(new_title)

    def cmd__lsf(self):
        """
        List favorites

        Usage: lsf
        """

        monitor = self.open_monitor('Favorites')
        self.entries = {}
        for index, (url, (name, comment)) in enumerate(self.favorites.items()):
            self.entries[index] = name, url
            monitor.write(f'{index:>4}: {name} | {comment}')
