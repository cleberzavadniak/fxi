import json
from os import environ
from pathlib import PosixPath
from queue import Queue, Empty
import threading
import tkinter
from tkinter import ttk
import time

from fxi.widgets.scrollables import VerticalScrolledFrame
from fxi.monitor import Monitor
from fxi.utils import apply_surrogates


cmd_names_map = {
    '/': 'SLASH',
    '.': 'DOT',
    ':': 'COLON',
    ';': 'SEMICOLON'
}


class InfoContext:
    def __init__(self, app, message):
        self.app = app
        self.message = message
        self.info(self.message)

    def info(self, message):
        if message:
            print(f'{self.app.title}: {message}')
            message = apply_surrogates(message)
        self.app.fxi.info(message)

    def __enter__(self):
        pass

    def __exit__(self, ex_type, ex_value, traceback):
        if ex_type:
            msg = f'{ex_type}: {ex_value}'
            self.info(msg)
            print(traceback)
            return
        self.info(None)


class AppBase:
    title = 'App Title'

    def __init__(self, fxi):
        self.fxi = fxi
        self.notebook = fxi.notebook
        self.tab = VerticalScrolledFrame(
            self.notebook,
            relief=tkinter.SUNKEN,
        )
        self.alive = True

        self.main_list = None
        self.current_monitor = None

        self.unsaved_config = {}
        self.load_config()

        self.tasks_queue = Queue()
        self.threads_pool = []

    def init(self):
        pass

    def quit(self):
        self.alive = False
        self.tab.destroy()
        self.persist_config()

    def new_thread(self, method, args=None, kwargs=None):
        args = args or ()
        kwargs = kwargs or {}
        t = threading.Thread(target=method, args=args, kwargs=kwargs)
        t.start()
        return t

    def info(self, message=None):
        return InfoContext(self, message)

    def render(self):
        pass

    def render_app(self):
        self.render()
        self.notebook.add_app(self)
        return self.tab

    def refresh(self):
        if self.main_list:
            self.main_list.refresh()

    def handle_command(self, head, args):
        cmd_name = cmd_names_map.get(head, head)

        method_name = f'cmd__{cmd_name}'
        method = getattr(self, method_name, None)
        if method:
            t = threading.Thread(target=method, args=args)
            t.start()
            return

        self.info(f'Unknown command: {cmd_name}')

    def cmd__help(self):
        """Show help about available commands"""

        monitor = self.open_monitor(f'{self.title}: Help')
        for entry_name in dir(self):
            if entry_name.startswith('cmd__'):
                name = entry_name.replace('cmd__', '')
                method = getattr(self, entry_name)
                doc = method.__doc__

                monitor.h2(name)
                if doc:
                    monitor.write_fixed(doc)
                monitor.hr()

    def open_monitor(self, name=None):
        self.close_monitor()

        monitor = Monitor(self, relief=tkinter.RIDGE)
        name ?? monitor.h1(name)

        self.current_monitor = monitor
        self.show_current_monitor()
        return monitor

    def show_current_monitor(self):
        self.current_monitor?.pack(expand=True, fill='both')

    def close_monitor(self):
        self.current_monitor?.close()

    def h1(self, title):
        label = ttk.Label(
            self.tab.interior,
            text=f'{title}',
            anchor=tkinter.W,
            justify=tkinter.LEFT,
            style='h1.TLabel'
        )

        label.pack(expand=True, fill='x')

    def get_config_or_ask(self, key, hidden=False, label=None, default=None):
        if key in self.config:
            return self.config[key]

        label = label or key

        if default is not None:
            label = f'{label} [{default}]'

        value = self.fxi.prompt.ask(label, hidden=hidden) or default
        self.unsaved_config[key] = value
        return value

    def load_config(self):
        basedir = PosixPath(environ['HOME']) / '.config' / 'fxi' / 'apps'
        basedir.mkdir(exist_ok=True, parents=True)
        filename = (self.title |> .lower() |> .replace(' ', '_')) |> (+)$(?, '.json')
        path = basedir / filename

        self.config_path = path

        if not path.exists():
            with path.open('w') as file_object:
                pass
            self.config = {}
            return

        with path.open('r') as file_object:
            content = file_object.read()

            if not content:
                self.config = {}
                return

            self.config = json.loads(content)

    def reload_config(self):
        with self.config_path.open('r') as file_object:
            content = file_object.read()
            if not content:
                return
        self.config = json.loads(content)

    def set_config(self, key, value):
        self.reload_config()
        self.config[key] = value
        self.persist_config()

    def get_config(self, key, default=None):
        return self.config.get(key, default)

    def persist_unsaved_config(self):
        for key, value in tuple(self.unsaved_config.items()):
            self.config[key] = value
            del self.unsaved_config[key]
        self.persist_config()

    def persist_config(self):
        with self.config_path.open('w') as file_object:
            json.dump(self.config, file_object)

    def enqueue(self, function, *args, **kwargs):
        self.tasks_queue.put((function, args, kwargs))

        num_threads = len(self.threads_pool)
        qsize = self.tasks_queue.qsize()

        if num_threads == 0 and qsize > 0:
            self.add_thread_to_pool()
        elif qsize > num_threads / 2:
            self.add_thread_to_pool()

    def tasks_thread(self):
        while self.alive:
            try:
                task = self.tasks_queue.get(timeout=1)
            except Empty:
                time.sleep(0.5)
                continue

            function, args, kwargs = task
            try:
                function(*args, **kwargs)
            except Exception as ex:
                the_type = type(ex)
                print(f'{the_type}: {ex}')
                continue

    def add_thread_to_pool(self):
        t = threading.Thread(target=self.tasks_thread)
        t.start()
        return t

    def ask(self, *args, **kwargs):
        return self.fxi.prompt.ask(*args, **kwargs)

    def top(self):
        self.tab.master.master.canvas.yview_scroll(-1000, "pages")

    def page_down(self):
        self.tab.master.master.page_down()

    def cmd__later(self, *parts):
        """Save commands for later (instead of opening new tabs)"""
        cmd = parts |> ' '.join

        if not cmd:
            return self.ls_later_list()

        key = 'app:later_list'
        later_list = self.get_config(key, [])
        later_list.append(cmd)
        self.set_config(key, later_list)
        self.info(f'Saved "{cmd}" for later.')

    def ls_later_list(self):
        key = 'app:later_list'
        later_list = self.get_config(key, [])

        monitor = self.open_monitor('Later List')
        for index, item in enumerate(later_list):
            monitor.write(f'{index:>4}: {item}')
